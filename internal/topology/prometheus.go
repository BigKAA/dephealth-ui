package topology

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PrometheusClient queries Prometheus/VictoriaMetrics for topology data.
type PrometheusClient interface {
	// QueryTopologyEdges returns all unique topology edges.
	QueryTopologyEdges(ctx context.Context, opts QueryOptions) ([]TopologyEdge, error)

	// QueryHealthState returns the current health value per edge.
	QueryHealthState(ctx context.Context, opts QueryOptions) (map[EdgeKey]float64, error)

	// QueryAvgLatency returns the average latency per edge.
	QueryAvgLatency(ctx context.Context, opts QueryOptions) (map[EdgeKey]float64, error)

	// QueryP99Latency returns the P99 latency per edge.
	QueryP99Latency(ctx context.Context, opts QueryOptions) (map[EdgeKey]float64, error)

	// QueryTopologyEdgesLookback returns all unique topology edges seen within
	// the given lookback window, including stale (disappeared) series.
	// It uses last_over_time() to retrieve the last known value for each edge.
	QueryTopologyEdgesLookback(ctx context.Context, opts QueryOptions, lookback time.Duration) ([]TopologyEdge, error)

	// QueryInstances returns all instances (pods/containers) for a given service.
	QueryInstances(ctx context.Context, serviceName string) ([]Instance, error)

	// QueryDependencyStatus returns the active status per edge (SDK v0.4.1).
	// Uses app_dependency_status == 1 to find the active enum value.
	QueryDependencyStatus(ctx context.Context, opts QueryOptions) (map[EdgeKey]string, error)

	// QueryDependencyStatusDetail returns the status detail per edge (SDK v0.4.1).
	// Uses app_dependency_status_detail == 1 for the info-pattern metric.
	QueryDependencyStatusDetail(ctx context.Context, opts QueryOptions) (map[EdgeKey]string, error)

	// QueryHistoricalAlerts returns alerts reconstructed from the ALERTS metric
	// at a given historical timestamp. Used instead of AlertManager in history mode.
	QueryHistoricalAlerts(ctx context.Context, at time.Time) ([]HistoricalAlert, error)

	// QueryStatusRange queries app_dependency_status == 1 over a time range
	// and returns per-edge time series data for transition detection.
	QueryStatusRange(ctx context.Context, start, end time.Time, step time.Duration, namespace string) ([]RangeResult, error)
}

// PrometheusConfig holds Prometheus connection settings.
type PrometheusConfig struct {
	URL      string
	Username string
	Password string
	Timeout  time.Duration
}

type prometheusClient struct {
	cfg    PrometheusConfig
	client *http.Client
}

// NewPrometheusClient creates a new Prometheus client.
func NewPrometheusClient(cfg PrometheusConfig) PrometheusClient {
	timeout := cfg.Timeout
	if timeout == 0 {
		timeout = 10 * time.Second
	}
	return &prometheusClient{
		cfg:    cfg,
		client: &http.Client{Timeout: timeout},
	}
}

// PromQL query templates for topology construction.
// When namespace is provided, a label filter is injected.
const (
	queryTopologyEdges = `group by (name, namespace, group, dependency, type, host, port, critical) (app_dependency_health%s)`
	queryHealthState   = `app_dependency_health%s`
	queryAvgLatency    = `rate(app_dependency_latency_seconds_sum%s[5m]) / rate(app_dependency_latency_seconds_count%s[5m])`
	queryP99Latency    = `histogram_quantile(0.99, rate(app_dependency_latency_seconds_bucket%s[5m]))`
	queryInstances     = `group by (instance, pod, job) (app_dependency_health{name="%s"})`
	// queryTopologyEdgesLookback uses last_over_time to include stale series.
	queryTopologyEdgesLookback = `group by (name, namespace, group, dependency, type, host, port, critical) (last_over_time(app_dependency_health%s[%s]))`
	// SDK v0.4.1: dependency status (enum pattern, exactly one series == 1 per endpoint).
	queryDependencyStatus       = `app_dependency_status%s == 1`
	queryDependencyStatusDetail = `app_dependency_status_detail%s == 1`
	// ALERTS metric is automatically generated by Prometheus/VM for all alerting rules.
	queryHistoricalAlerts = `ALERTS{alertstate="firing"}`
)

// nsFilter returns a PromQL label filter for the given namespace.
// Returns empty string if namespace is empty.
func nsFilter(ns string) string {
	if ns == "" {
		return ""
	}
	return fmt.Sprintf(`{namespace="%s"}`, ns)
}

// optFilter returns a PromQL label filter combining namespace and group from QueryOptions.
// Returns empty string if neither is set. Examples:
//
//	{namespace="prod"}, {group="cluster-1"}, {namespace="prod",group="cluster-1"}
func optFilter(opts QueryOptions) string {
	var parts []string
	if opts.Namespace != "" {
		parts = append(parts, fmt.Sprintf(`namespace="%s"`, opts.Namespace))
	}
	if opts.Group != "" {
		parts = append(parts, fmt.Sprintf(`group="%s"`, opts.Group))
	}
	if len(parts) == 0 {
		return ""
	}
	return "{" + strings.Join(parts, ",") + "}"
}

// promResponse represents Prometheus API v1 instant query response.
type promResponse struct {
	Status string   `json:"status"`
	Data   promData `json:"data"`
}

type promData struct {
	ResultType string       `json:"resultType"`
	Result     []promResult `json:"result"`
}

type promResult struct {
	Metric map[string]string  `json:"metric"`
	Value  [2]json.RawMessage `json:"value"`
}

func (c *prometheusClient) query(ctx context.Context, promql string, at *time.Time) ([]promResult, error) {
	u, err := url.Parse(c.cfg.URL)
	if err != nil {
		return nil, fmt.Errorf("invalid prometheus URL: %w", err)
	}
	u.Path = "/api/v1/query"
	params := url.Values{"query": {promql}}
	if at != nil {
		params.Set("time", fmt.Sprintf("%d", at.Unix()))
	}
	u.RawQuery = params.Encode()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if c.cfg.Username != "" {
		req.SetBasicAuth(c.cfg.Username, c.cfg.Password)
	}

	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("querying prometheus: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("prometheus returned %d: %s", resp.StatusCode, string(body))
	}

	var pr promResponse
	if err := json.Unmarshal(body, &pr); err != nil {
		return nil, fmt.Errorf("parsing response: %w", err)
	}

	if pr.Status != "success" {
		return nil, fmt.Errorf("prometheus query failed: status=%s", pr.Status)
	}

	return pr.Data.Result, nil
}

// promRangeResponse represents Prometheus API v1 range query response.
type promRangeResponse struct {
	Status string        `json:"status"`
	Data   promRangeData `json:"data"`
}

type promRangeData struct {
	ResultType string            `json:"resultType"`
	Result     []promMatrixEntry `json:"result"`
}

type promMatrixEntry struct {
	Metric map[string]string    `json:"metric"`
	Values []json.RawMessage    `json:"values"` // each element is [timestamp, "value"]
}

func (c *prometheusClient) queryRange(ctx context.Context, promql string, start, end time.Time, step time.Duration) ([]promMatrixEntry, error) {
	u, err := url.Parse(c.cfg.URL)
	if err != nil {
		return nil, fmt.Errorf("invalid prometheus URL: %w", err)
	}
	u.Path = "/api/v1/query_range"
	u.RawQuery = url.Values{
		"query": {promql},
		"start": {fmt.Sprintf("%d", start.Unix())},
		"end":   {fmt.Sprintf("%d", end.Unix())},
		"step":  {fmt.Sprintf("%d", int(step.Seconds()))},
	}.Encode()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if c.cfg.Username != "" {
		req.SetBasicAuth(c.cfg.Username, c.cfg.Password)
	}

	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("querying prometheus range: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("prometheus returned %d: %s", resp.StatusCode, string(body))
	}

	var pr promRangeResponse
	if err := json.Unmarshal(body, &pr); err != nil {
		return nil, fmt.Errorf("parsing range response: %w", err)
	}

	if pr.Status != "success" {
		return nil, fmt.Errorf("prometheus range query failed: status=%s", pr.Status)
	}

	return pr.Data.Result, nil
}

// QueryStatusRange queries app_dependency_status == 1 over a range and returns
// per-edge time series with status labels and timestamped values.
func (c *prometheusClient) QueryStatusRange(ctx context.Context, start, end time.Time, step time.Duration, namespace string) ([]RangeResult, error) {
	f := nsFilter(namespace)
	promql := fmt.Sprintf(queryDependencyStatus, f)

	entries, err := c.queryRange(ctx, promql, start, end, step)
	if err != nil {
		return nil, fmt.Errorf("querying status range: %w", err)
	}

	results := make([]RangeResult, 0, len(entries))
	for _, entry := range entries {
		key := EdgeKey{
			Name: entry.Metric["name"],
			Host: entry.Metric["host"],
			Port: entry.Metric["port"],
		}
		status := entry.Metric["status"]

		values, err := parseMatrixValues(entry.Values)
		if err != nil {
			continue
		}

		results = append(results, RangeResult{
			Key:    key,
			Status: status,
			Values: values,
		})
	}
	return results, nil
}

// parseMatrixValues parses the raw JSON values from a Prometheus matrix response.
// Each element is a two-element array: [unix_timestamp, "string_value"].
func parseMatrixValues(raw []json.RawMessage) ([]TimeValue, error) {
	values := make([]TimeValue, 0, len(raw))
	for _, r := range raw {
		var pair [2]json.RawMessage
		if err := json.Unmarshal(r, &pair); err != nil {
			continue
		}

		var ts float64
		if err := json.Unmarshal(pair[0], &ts); err != nil {
			continue
		}

		var valStr string
		if err := json.Unmarshal(pair[1], &valStr); err != nil {
			continue
		}

		val, err := strconv.ParseFloat(valStr, 64)
		if err != nil {
			continue
		}

		values = append(values, TimeValue{
			Timestamp: time.Unix(int64(ts), 0).UTC(),
			Value:     val,
		})
	}
	return values, nil
}

func (c *prometheusClient) QueryTopologyEdges(ctx context.Context, opts QueryOptions) ([]TopologyEdge, error) {
	f := optFilter(opts)
	results, err := c.query(ctx, fmt.Sprintf(queryTopologyEdges, f), opts.Time)
	if err != nil {
		return nil, err
	}

	edges := make([]TopologyEdge, 0, len(results))
	for _, r := range results {
		edges = append(edges, TopologyEdge{
			Name:       r.Metric["name"],
			Namespace:  r.Metric["namespace"],
			Group:      r.Metric["group"],
			Dependency: r.Metric["dependency"],
			Type:       r.Metric["type"],
			Host:       r.Metric["host"],
			Port:       r.Metric["port"],
			Critical:   r.Metric["critical"] == "yes",
		})
	}
	return edges, nil
}

func (c *prometheusClient) QueryTopologyEdgesLookback(ctx context.Context, opts QueryOptions, lookback time.Duration) ([]TopologyEdge, error) {
	f := optFilter(opts)
	lb := formatPromDuration(lookback)
	results, err := c.query(ctx, fmt.Sprintf(queryTopologyEdgesLookback, f, lb), opts.Time)
	if err != nil {
		return nil, err
	}

	edges := make([]TopologyEdge, 0, len(results))
	for _, r := range results {
		edges = append(edges, TopologyEdge{
			Name:       r.Metric["name"],
			Namespace:  r.Metric["namespace"],
			Group:      r.Metric["group"],
			Dependency: r.Metric["dependency"],
			Type:       r.Metric["type"],
			Host:       r.Metric["host"],
			Port:       r.Metric["port"],
			Critical:   r.Metric["critical"] == "yes",
		})
	}
	return edges, nil
}

// formatPromDuration converts a Go duration to a Prometheus duration string (e.g., "1h", "30m").
func formatPromDuration(d time.Duration) string {
	if h := int(d.Hours()); h > 0 && d == time.Duration(h)*time.Hour {
		return fmt.Sprintf("%dh", h)
	}
	if m := int(d.Minutes()); m > 0 && d == time.Duration(m)*time.Minute {
		return fmt.Sprintf("%dm", m)
	}
	return fmt.Sprintf("%ds", int(d.Seconds()))
}

func (c *prometheusClient) QueryHealthState(ctx context.Context, opts QueryOptions) (map[EdgeKey]float64, error) {
	f := optFilter(opts)
	results, err := c.query(ctx, fmt.Sprintf(queryHealthState, f), opts.Time)
	if err != nil {
		return nil, err
	}
	return parseEdgeValues(results)
}

func (c *prometheusClient) QueryAvgLatency(ctx context.Context, opts QueryOptions) (map[EdgeKey]float64, error) {
	f := optFilter(opts)
	results, err := c.query(ctx, fmt.Sprintf(queryAvgLatency, f, f), opts.Time)
	if err != nil {
		return nil, err
	}
	return parseEdgeValues(results)
}

func (c *prometheusClient) QueryP99Latency(ctx context.Context, opts QueryOptions) (map[EdgeKey]float64, error) {
	f := optFilter(opts)
	results, err := c.query(ctx, fmt.Sprintf(queryP99Latency, f), opts.Time)
	if err != nil {
		return nil, err
	}
	return parseEdgeValues(results)
}

// QueryInstances returns all instances (pods/containers) for a given service.
func (c *prometheusClient) QueryInstances(ctx context.Context, serviceName string) ([]Instance, error) {
	results, err := c.query(ctx, fmt.Sprintf(queryInstances, serviceName), nil)
	if err != nil {
		return nil, err
	}

	instances := make([]Instance, 0, len(results))
	for _, r := range results {
		inst := Instance{
			Instance: r.Metric["instance"],
			Pod:      r.Metric["pod"],
			Job:      r.Metric["job"],
			Service:  serviceName,
		}
		// Skip if instance is empty (shouldn't happen, but defensive)
		if inst.Instance == "" {
			continue
		}
		instances = append(instances, inst)
	}

	return instances, nil
}

func (c *prometheusClient) QueryDependencyStatus(ctx context.Context, opts QueryOptions) (map[EdgeKey]string, error) {
	f := optFilter(opts)
	results, err := c.query(ctx, fmt.Sprintf(queryDependencyStatus, f), opts.Time)
	if err != nil {
		return nil, err
	}
	return parseEdgeStringValues(results, "status"), nil
}

func (c *prometheusClient) QueryDependencyStatusDetail(ctx context.Context, opts QueryOptions) (map[EdgeKey]string, error) {
	f := optFilter(opts)
	results, err := c.query(ctx, fmt.Sprintf(queryDependencyStatusDetail, f), opts.Time)
	if err != nil {
		return nil, err
	}
	return parseEdgeStringValues(results, "detail"), nil
}

// parseEdgeStringValues extracts a named label value per EdgeKey from promResults.
func parseEdgeStringValues(results []promResult, label string) map[EdgeKey]string {
	m := make(map[EdgeKey]string, len(results))
	for _, r := range results {
		key := EdgeKey{
			Name: r.Metric["name"],
			Host: r.Metric["host"],
			Port: r.Metric["port"],
		}
		if v := r.Metric[label]; v != "" {
			m[key] = v
		}
	}
	return m
}

// QueryHistoricalAlerts queries the ALERTS metric at a historical timestamp
// and returns reconstructed alerts. Labels typically include: alertname,
// namespace, name (or service), severity.
func (c *prometheusClient) QueryHistoricalAlerts(ctx context.Context, at time.Time) ([]HistoricalAlert, error) {
	results, err := c.query(ctx, queryHistoricalAlerts, &at)
	if err != nil {
		return nil, fmt.Errorf("querying historical alerts: %w", err)
	}

	alerts := make([]HistoricalAlert, 0, len(results))
	for _, r := range results {
		svc := r.Metric["name"]
		if svc == "" {
			svc = r.Metric["service"]
		}
		if svc == "" {
			svc = r.Metric["job"]
		}
		if svc == "" {
			continue
		}
		alerts = append(alerts, HistoricalAlert{
			AlertName:  r.Metric["alertname"],
			Namespace:  r.Metric["namespace"],
			Service:    svc,
			Dependency: r.Metric["dependency"],
			Severity:   r.Metric["severity"],
		})
	}
	return alerts, nil
}

func parseEdgeValues(results []promResult) (map[EdgeKey]float64, error) {
	m := make(map[EdgeKey]float64, len(results))
	for _, r := range results {
		key := EdgeKey{
			Name: r.Metric["name"],
			Host: r.Metric["host"],
			Port: r.Metric["port"],
		}

		var valStr string
		if err := json.Unmarshal(r.Value[1], &valStr); err != nil {
			continue
		}
		val, err := strconv.ParseFloat(valStr, 64)
		if err != nil {
			continue
		}
		// For health: take minimum (worst) across instances.
		// For latency: take maximum across instances.
		if existing, ok := m[key]; ok {
			if val < existing {
				m[key] = val
			}
		} else {
			m[key] = val
		}
	}
	return m, nil
}
